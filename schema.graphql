# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateComponent {
  _count: ComponentCountAggregate
  _max: ComponentMaxAggregate
  _min: ComponentMinAggregate
}

type AggregatePackageType {
  _count: PackageTypeCountAggregate
  _max: PackageTypeMaxAggregate
  _min: PackageTypeMinAggregate
}

type Component {
  id: String!
  name: String!
  packageType: PackageType!
  packageTypeID: String!
}

type ComponentCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  packageTypeID: Int!
}

input ComponentCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  packageTypeID: SortOrder
}

input ComponentCreateInput {
  id: String
  name: String!
  packageType: PackageTypeCreateNestedOneWithoutComponentsInput!
}

input ComponentCreateManyInput {
  id: String
  name: String!
  packageTypeID: String!
}

input ComponentCreateManyPackageTypeInput {
  id: String
  name: String!
}

input ComponentCreateManyPackageTypeInputEnvelope {
  data: [ComponentCreateManyPackageTypeInput!]!
  skipDuplicates: Boolean
}

input ComponentCreateNestedManyWithoutPackageTypeInput {
  connect: [ComponentWhereUniqueInput!]
  connectOrCreate: [ComponentCreateOrConnectWithoutPackageTypeInput!]
  create: [ComponentCreateWithoutPackageTypeInput!]
  createMany: ComponentCreateManyPackageTypeInputEnvelope
}

input ComponentCreateOrConnectWithoutPackageTypeInput {
  create: ComponentCreateWithoutPackageTypeInput!
  where: ComponentWhereUniqueInput!
}

input ComponentCreateWithoutPackageTypeInput {
  id: String
  name: String!
}

type ComponentGroupBy {
  _count: ComponentCountAggregate
  _max: ComponentMaxAggregate
  _min: ComponentMinAggregate
  id: String!
  name: String!
  packageTypeID: String!
}

input ComponentListRelationFilter {
  every: ComponentWhereInput
  none: ComponentWhereInput
  some: ComponentWhereInput
}

type ComponentMaxAggregate {
  id: String
  name: String
  packageTypeID: String
}

input ComponentMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  packageTypeID: SortOrder
}

type ComponentMinAggregate {
  id: String
  name: String
  packageTypeID: String
}

input ComponentMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  packageTypeID: SortOrder
}

input ComponentOrderByRelationAggregateInput {
  _count: SortOrder
}

input ComponentOrderByWithAggregationInput {
  _count: ComponentCountOrderByAggregateInput
  _max: ComponentMaxOrderByAggregateInput
  _min: ComponentMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  packageTypeID: SortOrder
}

input ComponentOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  packageType: PackageTypeOrderByWithRelationInput
  packageTypeID: SortOrder
}

enum ComponentScalarFieldEnum {
  id
  name
  packageTypeID
}

input ComponentScalarWhereInput {
  AND: [ComponentScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ComponentScalarWhereInput!]
  OR: [ComponentScalarWhereInput!]
  packageTypeID: StringFilter
}

input ComponentScalarWhereWithAggregatesInput {
  AND: [ComponentScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  NOT: [ComponentScalarWhereWithAggregatesInput!]
  OR: [ComponentScalarWhereWithAggregatesInput!]
  packageTypeID: StringWithAggregatesFilter
}

input ComponentUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  packageType: PackageTypeUpdateOneRequiredWithoutComponentsNestedInput
}

input ComponentUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ComponentUpdateManyWithoutPackageTypeNestedInput {
  connect: [ComponentWhereUniqueInput!]
  connectOrCreate: [ComponentCreateOrConnectWithoutPackageTypeInput!]
  create: [ComponentCreateWithoutPackageTypeInput!]
  createMany: ComponentCreateManyPackageTypeInputEnvelope
  delete: [ComponentWhereUniqueInput!]
  deleteMany: [ComponentScalarWhereInput!]
  disconnect: [ComponentWhereUniqueInput!]
  set: [ComponentWhereUniqueInput!]
  update: [ComponentUpdateWithWhereUniqueWithoutPackageTypeInput!]
  updateMany: [ComponentUpdateManyWithWhereWithoutPackageTypeInput!]
  upsert: [ComponentUpsertWithWhereUniqueWithoutPackageTypeInput!]
}

input ComponentUpdateManyWithWhereWithoutPackageTypeInput {
  data: ComponentUpdateManyMutationInput!
  where: ComponentScalarWhereInput!
}

input ComponentUpdateWithoutPackageTypeInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ComponentUpdateWithWhereUniqueWithoutPackageTypeInput {
  data: ComponentUpdateWithoutPackageTypeInput!
  where: ComponentWhereUniqueInput!
}

input ComponentUpsertWithWhereUniqueWithoutPackageTypeInput {
  create: ComponentCreateWithoutPackageTypeInput!
  update: ComponentUpdateWithoutPackageTypeInput!
  where: ComponentWhereUniqueInput!
}

input ComponentWhereInput {
  AND: [ComponentWhereInput!]
  id: StringFilter
  name: StringFilter
  NOT: [ComponentWhereInput!]
  OR: [ComponentWhereInput!]
  packageType: PackageTypeRelationFilter
  packageTypeID: StringFilter
}

input ComponentWhereUniqueInput {
  AND: [ComponentWhereInput!]
  id: String
  name: StringFilter
  NOT: [ComponentWhereInput!]
  OR: [ComponentWhereInput!]
  packageType: PackageTypeRelationFilter
  packageTypeID: StringFilter
}

type Mutation {
  createManyComponent(data: [ComponentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPackageType(data: [PackageTypeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneComponent(data: ComponentCreateInput!): Component!
  createOnePackageType(data: PackageTypeCreateInput!): PackageType!
  deleteManyComponent(where: ComponentWhereInput): AffectedRowsOutput!
  deleteManyPackageType(where: PackageTypeWhereInput): AffectedRowsOutput!
  deleteOneComponent(where: ComponentWhereUniqueInput!): Component
  deleteOnePackageType(where: PackageTypeWhereUniqueInput!): PackageType
  updateManyComponent(data: ComponentUpdateManyMutationInput!, where: ComponentWhereInput): AffectedRowsOutput!
  updateManyPackageType(data: PackageTypeUpdateManyMutationInput!, where: PackageTypeWhereInput): AffectedRowsOutput!
  updateOneComponent(data: ComponentUpdateInput!, where: ComponentWhereUniqueInput!): Component
  updateOnePackageType(data: PackageTypeUpdateInput!, where: PackageTypeWhereUniqueInput!): PackageType
  upsertOneComponent(create: ComponentCreateInput!, update: ComponentUpdateInput!, where: ComponentWhereUniqueInput!): Component!
  upsertOnePackageType(create: PackageTypeCreateInput!, update: PackageTypeUpdateInput!, where: PackageTypeWhereUniqueInput!): PackageType!
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type PackageType {
  _count: PackageTypeCount
  components(cursor: ComponentWhereUniqueInput, distinct: [ComponentScalarFieldEnum!], orderBy: [ComponentOrderByWithRelationInput!], skip: Int, take: Int, where: ComponentWhereInput): [Component!]!
  id: String!
  name: String!
}

type PackageTypeCount {
  components(where: ComponentWhereInput): Int!
}

type PackageTypeCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input PackageTypeCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input PackageTypeCreateInput {
  components: ComponentCreateNestedManyWithoutPackageTypeInput
  id: String
  name: String!
}

input PackageTypeCreateManyInput {
  id: String
  name: String!
}

input PackageTypeCreateNestedOneWithoutComponentsInput {
  connect: PackageTypeWhereUniqueInput
  connectOrCreate: PackageTypeCreateOrConnectWithoutComponentsInput
  create: PackageTypeCreateWithoutComponentsInput
}

input PackageTypeCreateOrConnectWithoutComponentsInput {
  create: PackageTypeCreateWithoutComponentsInput!
  where: PackageTypeWhereUniqueInput!
}

input PackageTypeCreateWithoutComponentsInput {
  id: String
  name: String!
}

type PackageTypeGroupBy {
  _count: PackageTypeCountAggregate
  _max: PackageTypeMaxAggregate
  _min: PackageTypeMinAggregate
  id: String!
  name: String!
}

type PackageTypeMaxAggregate {
  id: String
  name: String
}

input PackageTypeMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type PackageTypeMinAggregate {
  id: String
  name: String
}

input PackageTypeMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input PackageTypeOrderByWithAggregationInput {
  _count: PackageTypeCountOrderByAggregateInput
  _max: PackageTypeMaxOrderByAggregateInput
  _min: PackageTypeMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input PackageTypeOrderByWithRelationInput {
  components: ComponentOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
}

input PackageTypeRelationFilter {
  is: PackageTypeWhereInput
  isNot: PackageTypeWhereInput
}

enum PackageTypeScalarFieldEnum {
  id
  name
}

input PackageTypeScalarWhereWithAggregatesInput {
  AND: [PackageTypeScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  NOT: [PackageTypeScalarWhereWithAggregatesInput!]
  OR: [PackageTypeScalarWhereWithAggregatesInput!]
}

input PackageTypeUpdateInput {
  components: ComponentUpdateManyWithoutPackageTypeNestedInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input PackageTypeUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input PackageTypeUpdateOneRequiredWithoutComponentsNestedInput {
  connect: PackageTypeWhereUniqueInput
  connectOrCreate: PackageTypeCreateOrConnectWithoutComponentsInput
  create: PackageTypeCreateWithoutComponentsInput
  update: PackageTypeUpdateToOneWithWhereWithoutComponentsInput
  upsert: PackageTypeUpsertWithoutComponentsInput
}

input PackageTypeUpdateToOneWithWhereWithoutComponentsInput {
  data: PackageTypeUpdateWithoutComponentsInput!
  where: PackageTypeWhereInput
}

input PackageTypeUpdateWithoutComponentsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input PackageTypeUpsertWithoutComponentsInput {
  create: PackageTypeCreateWithoutComponentsInput!
  update: PackageTypeUpdateWithoutComponentsInput!
  where: PackageTypeWhereInput
}

input PackageTypeWhereInput {
  AND: [PackageTypeWhereInput!]
  components: ComponentListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [PackageTypeWhereInput!]
  OR: [PackageTypeWhereInput!]
}

input PackageTypeWhereUniqueInput {
  AND: [PackageTypeWhereInput!]
  components: ComponentListRelationFilter
  id: String
  name: StringFilter
  NOT: [PackageTypeWhereInput!]
  OR: [PackageTypeWhereInput!]
}

type Query {
  aggregateComponent(cursor: ComponentWhereUniqueInput, orderBy: [ComponentOrderByWithRelationInput!], skip: Int, take: Int, where: ComponentWhereInput): AggregateComponent!
  aggregatePackageType(cursor: PackageTypeWhereUniqueInput, orderBy: [PackageTypeOrderByWithRelationInput!], skip: Int, take: Int, where: PackageTypeWhereInput): AggregatePackageType!
  component(where: ComponentWhereUniqueInput!): Component
  components(cursor: ComponentWhereUniqueInput, distinct: [ComponentScalarFieldEnum!], orderBy: [ComponentOrderByWithRelationInput!], skip: Int, take: Int, where: ComponentWhereInput): [Component!]!
  findFirstComponent(cursor: ComponentWhereUniqueInput, distinct: [ComponentScalarFieldEnum!], orderBy: [ComponentOrderByWithRelationInput!], skip: Int, take: Int, where: ComponentWhereInput): Component
  findFirstComponentOrThrow(cursor: ComponentWhereUniqueInput, distinct: [ComponentScalarFieldEnum!], orderBy: [ComponentOrderByWithRelationInput!], skip: Int, take: Int, where: ComponentWhereInput): Component
  findFirstPackageType(cursor: PackageTypeWhereUniqueInput, distinct: [PackageTypeScalarFieldEnum!], orderBy: [PackageTypeOrderByWithRelationInput!], skip: Int, take: Int, where: PackageTypeWhereInput): PackageType
  findFirstPackageTypeOrThrow(cursor: PackageTypeWhereUniqueInput, distinct: [PackageTypeScalarFieldEnum!], orderBy: [PackageTypeOrderByWithRelationInput!], skip: Int, take: Int, where: PackageTypeWhereInput): PackageType
  getComponent(where: ComponentWhereUniqueInput!): Component
  getPackageType(where: PackageTypeWhereUniqueInput!): PackageType
  groupByComponent(by: [ComponentScalarFieldEnum!]!, having: ComponentScalarWhereWithAggregatesInput, orderBy: [ComponentOrderByWithAggregationInput!], skip: Int, take: Int, where: ComponentWhereInput): [ComponentGroupBy!]!
  groupByPackageType(by: [PackageTypeScalarFieldEnum!]!, having: PackageTypeScalarWhereWithAggregatesInput, orderBy: [PackageTypeOrderByWithAggregationInput!], skip: Int, take: Int, where: PackageTypeWhereInput): [PackageTypeGroupBy!]!
  packageType(where: PackageTypeWhereUniqueInput!): PackageType
  packageTypes(cursor: PackageTypeWhereUniqueInput, distinct: [PackageTypeScalarFieldEnum!], orderBy: [PackageTypeOrderByWithRelationInput!], skip: Int, take: Int, where: PackageTypeWhereInput): [PackageType!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
